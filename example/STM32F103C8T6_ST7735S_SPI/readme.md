## 说明

### 1. 缘起

最近网购了几片LCD显示模块,商家提供的驱动性能非常差,在查看这些驱动的源代码时,发现有一些错误的注释,
网上也没有找到合适驱动代码.

理论上说,128 * 160 * 16bit = 327,680, SPI 18M的频率,每秒能发送的数据足够刷新50多次,即有一些损耗,也不至于FPS只有十几二十,

于是自己啃官方datasheet,编写基于SPI的LCD驱动,并且测试了开启DMA的效果

### 2. 性能数据

测试下来总体的性能,对于嵌入式来说已足够用了,以下是一个简单的测试数据

* 测试平台：SMT32F103C8T6核心开发板, 1.8寸 128*160, ST7735S驱动 LCD 显示屏 
* 系统时钟: 72M
* SPI时钟: 18M
* 开发环境: Keil 5.29 , STM32 HAL 库
以下不同显存情况下，用不同颜色清屏(128*160)刷新的的 FPS 数据

DRAM(byte)|256	|512	|1024	|1536	|2048	|2560	|3072	|3584	|4096	|5120	|7680	|8192
--------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------
无DMA	|49.86	|50.59	|50.9	|50.93	|50.89	|50.83	|50.74	|50.65	|50.56	|50.35	|49.84	|49.75
有DMA	|51.19	|52.84	|53.63	|53.81	|53.85	|53.84	|53.76	|53.71	|53.63	|53.45	|52.94	|52.85
性能提升	|2.60%	|4.26%	|5.09%	|5.35%	|5.50%	|5.59%	|5.62%	|5.70%	|5.72%	|5.80%	|5.86%	|5.87%


可以看出显存并不是越多性能越好,显存在大约1024-2048附近性能最佳, 是否开启编译优化也略有影响

对于嵌入式开发,25以上的fps已足够使用,采用DMA方式再提升3,5个百分点的效果并不明显，而由此占用了dma资源,
并且由于DMA中断,数据要分批发送,导致代码结构复杂,与其它功能耦合,不利于调试与移植复用,综合来看,不建议启用DMA

只有在以下两种场景下，可以考虑启用DMA

1. MCU负载较重，用DMA减轻显示的MCU的负载
2. RAM资源足够，能设置全屏显存,可以用DMA一次性刷新全屏,不需要分批发送,全屏显示可以做一些复杂的显示操作,
	全屏显存会导致FPS下降到20-22左右,若要提升显示体验,应选择更高SPI速度的MCU


18M的SPI时钟对全屏 128*160 16位颜色进行刷新,FPS要达到54.93,目前50帧左右的速度已接近理论的极限,
若要继续优化可以尝试修改或者重写 HAL_SPI_Transmit 函数中的代码,去除多余的判断


根据S7735S的官方文档,时钟周期(TSCYCW,Serial Clock Cycle (Write))最小值为66ns,可以支持15M的速度,
按全屏128*160*16bit数据计算,刷新一屏约21.6ms,FPS约46.

若假设时钟信号为理想的方波,只考虑时钟高低电平的持续时间,其最小周期约为 TSHW+TSLW=30ns, 可以支持33.3M的速率,FPS约102

从实际的测试结果看,官方文档非常保守(或者官方文档已过时,我参考的版本是V1.5_20150303).
用ACM32F403测试,SPI时钟在22.5M时, FPS可达到67左右,当SPI时钟置为45,开启编译优化后,测得FPS约136,刷新显示依然正常

用全屏图片刷新测试,FPS会有10%-15%左右的下降,这是正常现象,因为读取ROM速度与SDRAM不同

### 3. 性能提升的关键

在商家提供的驱动代码注释中有以下一段话 (看代码中的配置 SPI时钟为36M)

```
//如果使用官方库函数定义下列底层，速度将会下降到14帧每秒，建议采用我司推荐方法
//以下IO定义直接操作寄存器，快速IO操作，刷屏速率可以达到28帧每秒！ 

//GPIO置位（拉高）
#define	LCD_CS_SET  GPIO_TYPE->BSRR=1<<LCD_CS    //片选端口  	PB11
#define	LCD_RS_SET	GPIO_TYPE->BSRR=1<<LCD_RS    //数据/命令  	PB10	  
#define	LCD_RST_SET	GPIO_TYPE->BSRR=1<<LCD_RST   //复位			PB12

//GPIO复位（拉低）							    
#define	LCD_CS_CLR  GPIO_TYPE->BRR=1<<LCD_CS     //片选端口  	PB11
#define	LCD_RS_CLR	GPIO_TYPE->BRR=1<<LCD_RS     //数据/命令  	PB10	 
#define	LCD_RST_CLR	GPIO_TYPE->BRR=1<<LCD_RST    //复位			PB12


```

以上认为是寄存器操作引起的速度变化是错误的, GPIO 速度的远小于 SPI, 最影响速度的操作是频繁的 GPIO 操作,即不断地操作CS,D/C,
在批量发送数据时,把D/C拉高,再用HAL_SPI_Transmit 发送数据即可大大减少 GPIO 的操作.

以下是用寄存器操作与HAL操作GPIO的对比(显存DRAM 256 byte, SPI时钟 18M,无DMA)

	|寄存器操作|HAL库操作	
----|---------|---------
FPS	|49.86	  |49.85
	
可以看出性能变化几乎可以忽略

在项目中,如果要向LCD屏发送命令/数据前,先拉低CS,甚至有些项目就一块屏,CS在硬件连接就已拉低,就没有必要再操作CS,
每次发命令或者数据前拉低或者拉低D/C,在批量发送数据时没有必要频繁操作D/C或者CS
当然这样会让部分代码不能充分利用,但是在考虑性能的时候还是变通处理.

若考虑同一个SPI接口控制多块屏的显示,则要在驱动层或者显示接口层加增加启用与禁用指定屏的功能函数


### 4. 其它

驱动代码并没有实现完整的功能,只实现了简单的功能:
	
	* 如初始化(抄有原代码,略有修改)
	* 旋转
	* 镜像
	* 描点
	* 色块 (清屏,实心矩形)
	* 画图
	* 单色位图(acsii,汉字,单色图标等,相关资源需要自备)
	* 16位图片



### 5. 目录结构

项目的目录结构介绍如下:

proj 	keil项目目录
		用于存放项目相关的文件

sys 	系统文件目录
		用于存放,CMSIS,HAL_Driver等相关文件

lib 	库文件目录
		用于存放其它第三方库等相关文件

msp 	芯片支持层
		用配置时钟,GPIO,UART,SPI等

bsp 	板级支持层
		用于板子上的外设置配置,如LCD的对应管脚define,相关属性配置等

drv 	硬件驱动层
		用户存储硬件驱动相关的文件

api 	接口层
		接口层用于隔离应用层与驱动层,以便于复用,当更换mcu或者硬件时,只要修改对应的代码即可

app 	应用层
		即用户开发者需要编写的代码

ui 		界面组件库,依赖于api,为app层提供服务

res 	资源目录
		用于存放字库,图片等资源文件

驱动层依赖msp与bsp,如LCD驱动会用到SPI,以及GPIO的操作,为了尽量避免对驱动层文件的修改,将可配置的内容抽取出来,独立建立一个文件,存储在bsp中,而GPIO,SPI等资源的初始化,以及相关服务代码包括在msp中
接口层